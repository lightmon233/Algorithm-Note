# 机巧(经验之谈)

## 二进制

### gcc编译器自带库函数

`__builtin_popcount` 是GCC和一些其他C/C++编译器提供的内置函数（Intrinsic Function），用于计算一个整数中设置为1的位数（即计算二进制中1的个数，也称为"位计数"或"汉明重量"）。这个函数通常用于优化整数中1的位数计数的操作，因为它是编译器直接支持的，可以产生高效的机器代码。

`__builtin_popcount` 接受一个整数作为参数，并返回该整数中设置为1的位数的数量。

在C++中，`__lg` 通常用来表示"取以2为底的对数"，即以2为底的对数函数。它返回一个整数，表示某个值在以2为底的对数中的指数部分。这个函数通常在一些竞技性编程比赛中用于处理各种算法问题，因为它可以帮助进行高效的位操作。

`__lg` 通常用于计算以2为底的对数，例如 `__lg(8)` 的返回值是 `3`，因为 2^3 = 8。这个函数可以帮助优化某些算法中的运算，特别是与位操作相关的算法，如分治、动态规划等。

请注意，`__lg` 不是C++标准库的一部分，而是一些特定编译器或竞技性编程比赛平台提供的扩展。不同的编译器或平台可能有不同的名称或实现方式，因此在使用时需要查看相关文档或平台说明。在一些竞技性编程环境中，你可能会看到 `__lg` 的替代名称，如 `__builtin_clz`（计算前导零的数量，即前导0的个数）或 `__builtin_ctz`（计算尾随零的数量，即尾随0的个数），它们也用于进行位操作和对数计算。

## 等差数列各项平方求和公式

设首项为a1,公差为d的等差数列各项平方的和为：

=a1²+(a1+d)²+(a1+2d)²+--------+[a1+(n-1)d]²

=na1²+[2+4+6+-------+2(n-1)]d+[1²+2²+3²+-----+(n-1)²]d²

=na1²+n(n-1)d+n(n-1)(2n-1)d²

## 系数乘键值积排序求和定理（我瞎起的）

数组a[i]和数组b[i]

前者正向排序，后者逆向排序

然后每个元素乘积相加，这样得到的结果最小（前提a和b是非负数组）

## 唯一分解定理

唯一分解定理表明，每个大于1的正整数可以唯一地表示为质数的乘积，而且这个表示是唯一的，不考虑因子的顺序。

## 状态压缩中枚举子集的妙招

对于一个状态x, 他的子集可以这样枚举:

`for (int p = x; p != 0; p = (p - 1) & x)`

## 滚动数组最好倒着推的原因

因为要用上一层的状态，一般的状态转移形如`f[j] = ?f[k]?`, 其中j的值大于k的值，所以每个`f[j]`都由上一层的j左边的状态转移过来, 从左往右推的话其实j左边的状态已经刚刚算过了变成第i层的状态了，而不是上一层的状态。这个和01背包问题的1维优化类似。

如果不想倒着推，也可以开两个数组f，g交替着算，每次算之前先把上一层的f存到g里面，再进行转移。

## 逆序数和排列变成常序数列邻位调换次数相等怎么证?

准确来说，是最小使排列完全有序的邻位交换次数。因为每次邻位交换至多让逆序数减小1，完全有序排列的逆序数为0，所以使排列完全有序的邻位交换次数大于等于逆序数。因为存在逆序对时，一定存在相邻的两位是逆序，一直选择逆序的两位数交换，总可以用等于逆序对数量的邻位交换次数使排列完全有序，所以使排列完全有序的最小邻位交换次数小于等于逆序数。综上，逆序数是最小使排列完全有序的邻位交换次数。

作者：Hydrogen
链接：https://www.zhihu.com/question/553587531/answer/2828081213

### 用set求解mex

先把整个数组中出现的数全部放到set中，然后每枚举到一个位置，把当前位置上的数从set中删掉，这样当前前缀的mex就是set中最左的元素*set.begin()

### c++ double转long long的精度问题

当你确切地用到诸如1e18这种科学计数法的double类型时，最好把它强制转化成long long，并且如果用它来比较大小的话要把他设置的更大一点，比如你要判断x是否>1e18, 那么你可以写为x > 2e18

### 把一个permutation排序的最小交换次数

1. 只能交换相邻元素：逆序对数

2. 可以交换任意两个位置的元素：链接形成的环的数量

在原数组中，每个元素添加一个出边指向它最终的位置，这样画完出边后，

最少会成一个环，最多n个环。然后原理就是，最少交换次数=结点数n-形成的环数。

### manacher算法

```cpp
string longest_palindrome(string s) {
    auto pre_process = [](string s) -> string {
        int n = s.size();
        if (n == 0) return "^$";
        string res = "^";
        for (int i = 0; i < n; i ++) {
            res += "#" + s.substr(i, 1);
        }
        res += "#$";
        return res;
    };
    string t = pre_process(s);
    int n = t.size();
    int *p = new int[n];
    int C = 0, R = 0;
    for (int i = 1; i < n - 1; i ++) {
        int i_mirror = 2 * C - i;
        p[i] = R > i ? min(R - i, p[i_mirror]) : 0;
        while (t[i + 1 + p[i]] == t[i - 1 - p[i]]) p[i] ++;
        if (i + p[i] > R) {
            C = i;
            R = i + p[i];
        }
    }
    int max_len = 0, center = 0;
    for (int i = 1; i < n - 1; i ++) {
        if (p[i] > max_len) {
            max_len = p[i];
            center = i;
        }
    }
    delete[] p;
    return s.substr((center - max_len) / 2, max_len);
}
```

## p个人和q件工作

有$p$个人和$q$件工作，第$i$个人的能力值为$a_i$，第i项工作的难度为$b_i$，只有$a_i \ge b_j$才能让第$i$个人做第$x$项工作。每个人最多做一项工作，问所有工作是否都能被完成。

这是一个经典的贪心问题。首先选出能力值最高的q个人，然后将第i难的工作派给能力值第i高的人即可。

## 把一个数组里所有元素都变得相同至少需要的操作次数(每次只能让某个元素加一或者减一)

把所有数都变成中位数即可（如果长度为偶数，则中间两个数任意选一个）。

## 尽量不要用cin读入double，速度会很慢！

## 对一个负数取模把它变为正数可以这么做：

```cpp
x = (x % mod + mod) % mod;
```

## 一个序列，每次操作从任意ai拿一个x放到任意aj上，其中0<=x<=ai，则这样的操作只需做n次就一定可以做到将整个序列的sum任意分配到各个位置。

## 把sum分给n个位置，使得各个位置|起来的值最小，则从高位向低位贪心，可以证明如果在当前位不放1时无法把剩余的sum分配给后续位时，在当前位放置越多1越好。设这最多的1的数量为x，如果当前位置放置的数不到x，则后续其余位的和大于$2^bit$，由于满足进位关系，可证存在一个相同或者更好的方案是的当前位多放一个1。

就是证明后面的位往前进位可以进一个1到bit位，且不会把中途的0变成1

考虑当前位是bit，

假设bit位没有放尽可能多

这个时候考虑最终情况下，所有在bit后面的位的数的和> (1 << bit)

假设最后有数的位是010101010010111这样，1代表有，0代表没有

把所有有的位拉出来，形成新的进位关系，例如这里所有数的位的进位比率（进位比率即满多少进1）是4 4 4 4 8 4 2 2

考虑这些位之间进行进位直到不能进位为止，显然每一位要比自己的进位比率小，这个时候所有人的$\sigma < (1 << bit)$所以还有多的，所以可以证明最终会进位到bit这一位，所以证明了bit存在bit + 1的不劣的解

## 质数n的欧拉函数是n - 1

## 欧拉函数是质数的数只有3、4、6

## ^的优先级高于*, 要记得加括号

## 集合哈希

哈希：相同输入一定返回相同输出，不同输入大概率返回不同输出。

比如我们想判断两个序列是不是都是1~n的排列。

根据异或的交换律可知，一个数组的任何排列组合，它的异或结果都相同。
可以根据异或结果是否相同来判断两个数组是否是同一个排列组合。

但是也有很多其他组合异或后也是相同的结果, 比如1^2=5^6, 本质原因是组合数一共有$\frac{n\cdot(n-1)}{2}$，而异或的结果集 $\approx n$, 实际上是比n大的最小$2^k$。 

为了解决冲突我们可以利用哈希将异或的结果集扩大：将数字$i$哈希成 64 位无符号整数
那么结果集就扩大为了$2^{64}$，和$\frac{n\cdot(n-1)}{2}$相比，冲突的概率就是$\frac{n\cdot(n-1)}{2^{65}}$, 概率大大降低。

## mt19937_64生成unsigned long long类型随机值，mt19937生成unsigned int类型随机值。

## 质数表

![质数表](/static/img/质数表.jpg)

![质数分步定律](/static/img/质数分步定律.jpg)

## popcount

```cpp
__builtin_popcount = int
__builtin_popcountl = long int
__builtin_popcountll = long long
```